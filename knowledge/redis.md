- [基础](#基础)
    - [数据结构](#数据结构)
    - [批量指令](#批量指令)
    - [Redis的高并发和快速原因](#Redis的高并发和快速原因)
    - [缓存优点](#缓存优点)
    - [使用场景](#使用场景)
    - [Redis与Memcached的区别](#Redis与Memcached的区别)
    - [Redis数据丢失的情况](#Redis数据丢失的情况)
    - [持久化](#持久化)
    - [重启恢复](#重启恢复)
    - [过期策略](#过期策略)
    - [高可用](#高可用)
    - [集群](#集群)
    - [缓存设计](#缓存设计)
        - [缓存穿透](#缓存穿透)
        - [缓存雪崩](#缓存雪崩)
- [面试](#面试)
    - [Redis的高并发](#Redis的高并发)
    - [Redis优点](#Redis优点)
    - [Redis的持久化](#Redis的持久化)
    - [Redis哨兵](#Redis哨兵)
    - [Redis缓存穿透和缓存雪崩](#Redis缓存穿透和缓存雪崩)

---
# 基础
## 数据结构
![](../pictures/redis/redis_structure.png)

![](../pictures/redis/redis_inner_code.png)

## 批量指令
* 批量get/set(multi get/set)，一条指令，性能好。
* 管道（pipelining），多条指令包在一起，只请求一次redis。
* 事务（transaction），同个事务中指令串行执行，具有原子性。
* 基于事务的管道（transaction in pipelining）。

## Redis的高并发和快速原因
* redis是基于内存的，内存的读写速度非常快。
* redis是单线程的，省去了很多上下文切换线程的时间，预防了多线程可能产生的竞争问题。
* redis使用多路复用技术，可以处理并发的连接。非阻塞I/O内部实现采用epoll，再加上redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/OI/O上浪费过多的时间。

## 缓存优点
* 加速读写
* 降低后端负载

## 使用场景
* 缓存
* 排行榜系统：可以使用有序集合。
* 计数器应用：可以使用字符串。
* 社交网络
* 消息队列系统：可以使用列表。
* 分布式锁

## Redis与Memcached的区别
* Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
* Redis支持数据的备份，即master-slave模式的数据备份。
* Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
* 速度更快。
* 单个value的最大限制是1GB，不像memcached只能保存1MB的数据。

## Redis数据丢失的情况
* 是否有大量过期key被清理<br>
分析原因：这种情况并不是真正的“丢失”键值，只是达到了设置的key的过期值。<br>
应对方案：根据项目情况设置合理的键值过期时间，或者设置为不过期，对不使用的key进行删除。
* 是否maxmemory不足导致redis自动清理部分key以节省空间<br>
分析原因：redis内存使用达到设置的可用内存的上限，redis自动清理部分key已节省空间给新的key使用。<br>
应对方案：适当的调大maxmemory。
* 主库故障后自动重启<br>
分析原因：主库由于某种原因挂掉，但是在redis哨兵发现并启动切换之前被监控程序重启，如果主库有完整的备份策略，则丢失重启之前的一小段时间的数据，如果主库为了性能没有设置备份策略，则可能重启之后成为一个空的库，一段时间后，从库发现主库的runid发生变化，自动同步主库，导致数据丢失严重。<br>
应对方案：<br>
1、建议对主库使用至少一种持久化策略，即使频率低。<br>
2、如果没有完整的持久化策略不建议使用自动重启操作，特别是在redis集群方案中，因为在集群方案中使用哨兵的判断和操作是最安全的。
* 网络分区的问题，可能导致短时间的写入数据丢失
分析原因：网络不稳定导致的短时写入失败或触发哨兵的自动切换（单独的主备方案触发切换期间会有数据丢失）。<br>
应对方案：保障网络环境稳定可达。

## 持久化
Redis持久化（数据落地）：把数据保存到硬盘中。<br>

Redis持久化目的<br>
Redis的数据操作都在内存中，Redis崩掉的话，会丢失数据。Redis持久化对数据的更新异步地保存在磁盘上，以便数据恢复。

Redis持久化方式
* RDB：指定时间间隔进行快照存储，恢复速度快，可能丢失数据。
* AOF：记录写操作，文件大，保存频率高。

默认情况下，是快照rdb的持久化方式，将内存中的数据以快照的方式写入二进制文件中，默认的文件名是dump.rdb。这种方式不能完全保证数据持久化，因为是定时保存，所以当redis服务kill掉，就会丢失一部分数据，而且数据量大，写操作多的情况下，会引起大量的磁盘IO操作，会影响性能。
所以还要在使用aof做持久化，每一个写命令都通过write函数追加到appendonly.aof中。

## 重启恢复
当Redis服务器挂掉时，重启时将按照以下优先级恢复数据到内存：
1. 如果只配置AOF，重启时加载AOF文件恢复数据。
2. 如果同时配置了RDB和AOF，启动时只加载AOF文件恢复数据。
3. 如果只配置RDB，启动是加载dump文件恢复数据。

## 过期策略
内存回收策略：
* 惰性删除：读取键时，如果过期，删除并返回空，释放内存。缺点：容易导致内存泄漏：如果键一直没有被访问到则无法被及时删除，导致内存不能及时释放。
* 定时删除：定时任务循环采样一定数量的键，过期则删除。

## 高可用
当主节点出现故障时，Redis Sentinel（哨兵）能自动完成完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。<br>
Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，当大多数Sentinel节点都认为主节点不可达时，它们会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。

Redis Sentinel的实现原理
1. 三个定时任务
* 每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。
* 每隔2秒，每个Sentinel节点会向Redis数据节点的__sentinel__:hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。
* 每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确定这些节点当前是否可达。实现了对每个节点的监控。
2. 主观下线和客观下线
* 主观下线：Sentinel节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。存在误判的可能。
* 客观下线：当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is-master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel节点认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定。
3. Sentinel领导者选举：<br>
1、每个在线的Sentinel节点都有资格成为领导者，当它确认主节点主观下线时候，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求将自己设置为领导者。<br>
2、收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinel is-master-down-by-addr命令，将同意该请求，否则拒绝。
3、如果该Sentinel节点发现自己的票数已经大于等于max(quorum,num(sentinels)/2+1)，那么它将成为领导者。<br>
4、如果此过程没有选举出领导者，将进入下一次选举。
4. 故障转移：<br>
1、在从节点列表中选出一个节点作为新的主节点，选择方法如下：<br>
（a）过滤：“不健康”（主观下线、短线）、5秒内没有回复过Sentinel节点ping响应、与主节点失联超过down-after-milliseconds*10秒。<br>
（b）选择slave-priority（从节点优先级）最高的从节点列表，如果存在则返回，不存在则继续。<br>
（c）选择复制偏移量最大的从节点（复制的最完整），如果存在则返回，不存在则继续。<br>
（d）选择runid最小的从节点。<br>
2、Sentinel领导者节点会对第一步选出来的从节点执行slaveof no one命令让其成为主节点。<br>
3、Sentinel领导者节点会向剩余的从节点发送命令，让它们成为新主节点的从节点，复制规则和parallel-syncs参数有关。<br>
4、Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。<br>

从节点的作用
* 当主节点出现故障时，作为主节点的后备“顶”上来实现故障转移，Redis Sentinel已经实现了该功能的自动化，实现了真正的高可用。
* 扩展主节点的读能力，尤其是在读多写少的场景非常适用。

Redis Sentinel下的读写分离架构图
![](../pictures/redis/redis_sentinel.png)

## 集群
Redis Cluster是Redis的分布式解决方案，有效地解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构方案达到负载均衡的目的。

Redis集群自身实现了高可用。高可用首先需要解决集群部分失败的场景：当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。

## 缓存设计
### 缓存穿透
缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。

缓存穿透带来的问题<br>
缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。缓存穿透问题可能会使后端存储负载加大，由于很多后端存储不具备高并发性，甚至可能造成后端存储宕掉。<br>
通常可以在程序中分别统计总调用数、缓存层命中数、存储层命中数，如果发现大量存储层空命中，可能就是出现了缓存穿透问题。

造成缓存穿透的基本原因
* 自身业务代码或者数据出现问题。
* 一些恶意攻击、爬虫等造成大量空命中。

解决缓存穿透问题的方法
* 缓存空对象：存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取，这样就保护了后端数据源。
* 在访问缓存层和存储层之前，将存在的key用户用布隆过滤器提前保存起来，做第一层拦截。如果布隆过滤器认为该用户id不存在，那么就不会访问存储层，在一定程度保护了存储层。

![](../pictures/redis/cache_null.png)

### 缓存雪崩
缓存雪崩：由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求都会到达存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。

预防和解决缓存雪崩问题
* 保证缓存层服务高可用性。
* 依赖隔离组件为后端限流并降级。
* 提前演练。

# 面试
## Redis的高并发
[Redis的高并发](#Redis的高并发和快速原因)
## Redis优点
[Redis优点](#缓存优点)
## Redis的持久化
[Redis的持久化](#持久化)
## Redis哨兵
[Redis哨兵](#高可用)
## Redis缓存穿透和缓存雪崩
[缓存穿透](#缓存穿透) [缓存雪崩](#缓存雪崩)

